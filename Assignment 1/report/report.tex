\documentclass[11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[margin=.8in,top=1.1in,bottom=1.1in]{geometry} % page layout
\usepackage{amsmath,amsthm,amssymb,amsfonts} % math things
\usepackage{graphicx} % include graphics
\usepackage{fancyhdr} % header customization
\usepackage{titlesec} % help with section naming
\usepackage{csquotes}
\usepackage{color}

% headers
\pagestyle{fancy} 
\fancyhf{} % clear all
\fancyhead[L]{\sffamily\small Lab Course: High Performance Computing --- Assignment Report}
\fancyhead[R]{\sffamily\small Page \thepage}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0.2pt}
\markright{\hrulefill\quad}

\newcommand{\hwhead}[4]{
\begin{center}
\sffamily\large\bfseries Lab Course: High Performance Computing Assignment Report #1
\vspace{2mm} 
\normalfont

#2

#3
\end{center}
\vspace{6mm} \hrule \vspace{4mm}
}

% ------------------------------------------------------------------------------
% Start here -- Fill in your name, imat and email
% ------------------------------------------------------------------------------

\newcommand{\namea}{Frédéric Gillioz (03657002) \texttt{frederic.gillioz@tum.de}}
\newcommand{\nameb}{Andreas Amler (????) \texttt{???}}

\begin{document}

% ------------------------------------------------------------------------------
% Change xx (and only xx) to the current sheet number
% ------------------------------------------------------------------------------
\hwhead{1}{\namea}{\nameb}

% ------------------------------------------------------------------------------
% Fill in your solutions
% ------------------------------------------------------------------------------

\setcounter{section}{-1}
\section{General}

\begin{itemize}
\item Intel compiler 2017 installation on Ubuntu: Extracted installer package may not be located in a path containing a space character otherwise the installation procedure fails at the licensing step.
\item We have set-up a GitHub repository for collaborative working on the deliverables.
\end{itemize}

\section{Auto-vectorization}

\subsubsection*{Which kinds of loops can be vectorized automatically?}
Following conditions must be fulfilled:
\begin{itemize}
\item Innermost loops
\item No prohibiting data dependencies
\item Unit stride
\item Supported operations and data types in the loop body
\item Countable: The number of iterations must be known and fixed when entering the loop at runtime. The loop must only exit after the last iteration finished, in particular there may not be a data dependent exit point.
\end{itemize}

Dependency free innermost loops with unit stride and supported operations and data types.

\subsubsection*{Which datatypes and operations are allowed in order to enable auto-vectorization of loops?}
\begin{itemize}
\item Integers: Most arithmetic and logical operators on 32-bit, 16-bit and 8-bit integer data types are supported. There is limited support for 64-bit integer data types.
\item Decimals: For 32-bit and 64-bit floating-point numbers, SSE provides SIMD instructions for \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{min}, \texttt{max} and \texttt{sqrt}. When using a specialized vector mathematical run-time library some more operations are allowed such as trigonometric functions.
\end{itemize}

\subsubsection*{Which types of dependency analysis do the compiler perform?}

pointer aliasing
dependencies between loop iterations

\subsubsection*{How does programming style influence auto-vectorization?}
Programming style can inhibit vectorization. For example the existence of global pointers prevents the compiler to prove that there is no aliasing to a memory location which is subject to auto-vectorization. For the same reason one should make use of array notations instead of pointers.



Within the innermost loop, it is advisable to use straight-line code (no jumping, i.e. no \texttt{switch}, \texttt{goto} or \texttt{return} statements), use arrays as L-values only (constant expressions as R-values are ok) and to have only assignments. Simple \texttt{if} branches are possible if they can be treated as \textit{masked assignments}, i.e. an instruction is applied to the whole SIMD register but the resulting scalars are written back selectively.

Discouraged are calls to any functions (except math library calls), use of non-vectorizable operations and mixing of vectorizable data types.

Also the loop exit condition is not allowed to depend on the own loop's data. It must be invariant within the loop.

Dependencies between loop iterations are not allowed.

Manual loop unrolling and splitting a loop with a large body into multiple smaller loops should be avoided.

Access memory efficiently:
• Favor inner loops with unit stride.
• Minimize indirect addressing.
• Align your data to 16-byte boundaries (for Intel ® SSE instructions).

Use structure of arrays (SoA) instead of array of structures (AoS).

obstacles:
Non-contiguous memory access: non-unit stride or indirect addressing
Data dependencies (read-after-write not ok, write-after-read in simple situations ok, Read-after-read ok, Write-after-write in general not ok). ausnahme reductions, u.b. multiply-accumulate (MAC) operationen werden erkannt


\subsubsection*{Is there a way to assist the compiler through language extensions? If yes, please give details.}
In some cases, certain keywords or directives may be applied in the code in order to assist the auto-vectorization's dependency analysis. In the following distinguish proven and potential data dependencies. For proven data dependencies it is known at compile time for sure that there is a dependency which prohibits vectorization. A potential data dependency can only be detected at runtime, e.g. overlapping memory regions. Apart from the following macros and keywords, in order to deal with potential data dependencies the compiler might generate code to detect them at runtime and execute either the safe serial loop or a vectorized version.
\begin{itemize}
\item Pragmas just before the respective loop:
\begin{itemize}
\item \texttt{\#pragma novector}: Disables vectorization. Saves the code overhead for the runtime dependency check and vectorized loop version. Makes sense if there is no expected benefit from vectorization (e.g. small number of loop iterations) or it is known for sure that input and output memory regions will overlap.
\item \texttt{\#pragma ivdep}: Conversely, this ignores any potential data dependencies. Proven dependencies are not ignored. Saves the code overhead for the runtime dependency check and non-vectorized loop version. Potentially unsafe. Equivalent to the \texttt{restrict} keyword below.
\item \texttt{\#pragma loop count (n)}: Tells the compiler the typical number of loop iterations. Helps it to decide if vectorization would be beneficial.
\item \texttt{\#pragma vector always}: Vectorize even if the compiler thinks it is not beneficial. Does not ignore proven or potential data dependencies.
\item \texttt{\#pragma vector align}: Only for SSE instructions: Tells the compiler that the data in the loop is 16-bytes memory aligned. This allows for more efficient aligned data movement instructions to be used. Wrong usage results in SSE runtime exceptions.
\item \texttt{\#pragma vector nontemporal}: Tells the compiler that it should not consider temporal locality for the data. Allows to use more efficient store operations, bypassing the cache. Such a situation occurs for example when adding two vectors.
\item \textcolor{red}{\texttt{\#pragma SIMD}: F. 17?}
\end{itemize}
\item Keywords:
\begin{itemize}
\item \texttt{restrict}: Tells the compiler that it is safe to assume that the annotated pointer (or array) is not aliased, i.e. this pointer is the only reference to the pointed memory and memory does not overlap. Potentially unsafe. Equivalent to the \texttt{ivdep} pragma above.
\end{itemize}
\end{itemize}

Besides this, there exist compiler command line options that allow the compiler to globally collect information to improve its dependency analysis and trip count estimations.

\subsubsection*{Which loop optimizations are performed by the compiler in order to vectorize and pipeline loops?}
Loop unrolling.
Loop peeling?

\end{document}
